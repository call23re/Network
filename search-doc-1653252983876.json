[{"title":"Error Handling","type":0,"sectionRef":"#","url":"docs/Error Handling","content":"Error Handling","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/Getting Started/Installation","content":"","keywords":""},{"title":"With Wally​","type":1,"pageTitle":"Installation","url":"docs/Getting Started/Installation#with-wally","content":"[dependencies] Network = &quot;call23re/network@2.2.0&quot; Copy "},{"title":"Releases​","type":1,"pageTitle":"Installation","url":"docs/Getting Started/Installation#releases","content":"Download the latest .rbxm file.Drag it into studio.Move it into ReplicatedStorage. "},{"title":"Register","type":0,"sectionRef":"#","url":"api/Register","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Register","url":"api/Register#functions","content":" "},{"title":"GetEvent​","type":1,"pageTitle":"Register","url":"api/Register#GetEvent","content":"&lt;/&gt; Register.GetEvent( name: string-- The name of the remote event. ) → RemoteEvent   "},{"title":"GetFunction​","type":1,"pageTitle":"Register","url":"api/Register#GetFunction","content":"&lt;/&gt; Register.GetFunction( name: string-- The name of the remote function. ) → RemoteFunction  "},{"title":"Network","type":0,"sectionRef":"#","url":"api/Network","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Network","url":"api/Network#properties","content":" "},{"title":"Register​","type":1,"pageTitle":"Network","url":"api/Network#Register","content":"&lt;/&gt; Network.Register: function Registers remote objects.  "},{"title":"Event​","type":1,"pageTitle":"Network","url":"api/Network#Event","content":"&lt;/&gt; Network.Event: [RemoteEvent] RemoteEvent class.  "},{"title":"Function​","type":1,"pageTitle":"Network","url":"api/Network#Function","content":"&lt;/&gt; Network.Function: [RemoteFunction] RemoteFunction class.  "},{"title":"None​","type":1,"pageTitle":"Network","url":"api/Network#None","content":"&lt;/&gt; Network.None: Symbol Used to represent a nil value. "},{"title":"Chaining","type":0,"sectionRef":"#","url":"docs/Chaining","content":"Chaining In the context of this library, chaining is when methods return self or when promises return new promises. You use chaining to apply hooks when registering remotes. Encoded = Network.Event.new() :inbound(Middleware.Logger, &quot;Shared&quot;) :inbound(Transformers.Decode, &quot;Shared&quot;) :outbound(Middleware.Logger, &quot;Shared&quot;) :outbound(Transformers.Encode, &quot;Shared&quot;) :warn(true) Copy Because inbound, outbound, and warn return self, you can call them in succession in a single statement. You also use chaining in any case in which promises are used. TestFunction:InvokeServer(1, 2, 3) :andThen(function(a, b, c) assert(a == 2) assert(b == 3) assert(c == 4) print(a, b, c) end) :catch(warn) Copy See: https://eryn.io/roblox-lua-promise/docs/Tour#chaining for more information. It's also used in a special case when catching hook errors from connections. In this example, :catch is chained on to :Connect. Foo.OnServerEvent:Connect(function(value) print(value) end):catch(warn) Copy","keywords":""},{"title":"Register","type":0,"sectionRef":"#","url":"docs/Getting Started/Register","content":"","keywords":""},{"title":"Registering Hooks​","type":1,"pageTitle":"Register","url":"docs/Getting Started/Register#registering-hooks","content":"If you are using any Hooks, they need to be registered here as well. This can be done by chaining them on to your remote classes. Example: ReplicatedStorage/Remotes.lua local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Network = require(ReplicatedStorage.Packages.Network) local Middleware = require(script.Parent.Middleware) local Transformers = require(script.Parent.Transformers) return Network.Register({ Encoded = Network.Event.new() :inbound(Middleware.Logger, &quot;Shared&quot;) :inbound(Transformers.Decode, &quot;Shared&quot;) :outbound(Middleware.Logger, &quot;Shared&quot;) :outbound(Transformers.Encode, &quot;Shared&quot;) :warn(true) }) Copy "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/intro","content":"Introduction Network is a declarative networking library initially based on network and influenced by RbxNet. It was made with the following goals in mind: Feature parity with Roblox's remote objectsA familiar and consistent API to reduce frictionSupport for bidirectional mutable hooksComprehensive Luau types (soon™)Promisified remotesBuilt-in, promise-based error handlingAsynchronous Remote FunctionsEasy to integrate in to existing projectsExpanded remote API for common methods (FireClients, FireClientsExcept) All of these goals have been met in some capacity. Motivation Creating, accessing, modifying, and using remotes in studio is easy. So why should a library do it for you? Using a remote wrapper means that the source of truth for your remotes exists in your code instead of the data model. It also means that, typically, they're all defined in a single place, which is helpful for organization. This is particularly advantageous when you're using a tool like Rojo. It allows you to check your remotes in to version control and it saves time switching back-and-forth between studio and your code editor. It is also advantageous because it allows you to easily add extra behavior to your remotes through the form of Hooks. Drawbacks This isn't a replacement for RbxNet. It was not made for TypeScript and so it doesn't have some of the advantages of RbxNet (like compilation transformers). The scope of this project is also fairly limited in comparison. It doesn't have support for messaging service. It doesn't have any built-in middleware. It doesn't have explicit namespacing. Because it was made to more closely emulate the native remote APIs, some of the RbxNet naming conventions are arguably more clear. If you are using TypeScript, you should probably use RbxNet. If you're using Luau, it's mostly a matter of personal preference. This library relies heavily on promises. It expects the user to be familiar with promises. While there are many advantages to this, if you aren't familiar with them, it may be confusing at first. So, in using this library, you should familiarize yourself with promises as well. https://eryn.io/roblox-lua-promise/","keywords":""},{"title":"Remote Events","type":0,"sectionRef":"#","url":"docs/Getting Started/Remote Events","content":"","keywords":""},{"title":"Sending Data​","type":1,"pageTitle":"Remote Events","url":"docs/Getting Started/Remote Events#sending-data","content":"ServerClient ServerScriptService/Main.lua local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Remotes = require(ReplicatedStorage.Remotes) local Player = ... local Foo = Remotes.GetEvent(&quot;Foo&quot;) Foo:FireClient(Player, &quot;bar&quot;, &quot;baz&quot;):catch(warn) Copy Firing a Remote Event returns a promise. This is because hooks can fail, and if they do, it is important to catch them. If you have a hook that mutates data in any way, you can use andThen to grab a snapshot of the data that is ultimately sent. If you're not using any hooks, you don't need to chain anything. "},{"title":"Receiving Data​","type":1,"pageTitle":"Remote Events","url":"docs/Getting Started/Remote Events#receiving-data","content":"ServerClient ServerScriptService/Main.lua local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Remotes = require(ReplicatedStorage.Remotes) local Foo = Remotes.GetEvent(&quot;Foo&quot;) Foo:FireAllClients(&quot;bar&quot;) Foo.OnServerEvent:Connect(function(value) print(value) -- qux end):catch(warn) Copy Inbound hooks are fired on event as well. Events can catch hook errors via catch. If you're not using any hooks, you don't need to include catch. "},{"title":"Remote Functions","type":0,"sectionRef":"#","url":"docs/Getting Started/Remote Functions","content":"","keywords":""},{"title":"Invoking the Server​","type":1,"pageTitle":"Remote Functions","url":"docs/Getting Started/Remote Functions#invoking-the-server","content":"ServerClient ServerScriptService/Main.lua local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Remotes = require(ReplicatedStorage.Remotes) local State = {...} local GetState = Remotes.GetFunction(&quot;GetState&quot;) GetState.OnClientInvoke = function() return State end Copy "},{"title":"Invoking the Client​","type":1,"pageTitle":"Remote Functions","url":"docs/Getting Started/Remote Functions#invoking-the-client","content":"ServerClient ServerScriptService/Main.lua local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Remotes = require(ReplicatedStorage.Remotes) local Player = ... local Ready = Remotes.GetFunction(&quot;Ready&quot;) Ready:InvokeClient(Player) :andThen(function(isReady) assert(type(isReady) == &quot;boolean&quot;) print(Player, &quot;is&quot;, isReady and &quot;ready&quot; or &quot;not ready&quot;) end) :catch(warn) Copy warning Even though you can invoke the client, the client can still wait indefinitely to respond. While this won't yield, you still need some logic to clean up the promise under certain circumstances (like if the player leaves the game). Generally, it is bad practice to invoke the client. "},{"title":"RemoteFunction","type":0,"sectionRef":"#","url":"api/RemoteFunction","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"RemoteFunction","url":"api/RemoteFunction#properties","content":" "},{"title":"Name​","type":1,"pageTitle":"RemoteFunction","url":"api/RemoteFunction#Name","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; RemoteFunction.Name: string Refers to the name given to the RemoteFunction.  "},{"title":"ClassName​","type":1,"pageTitle":"RemoteFunction","url":"api/RemoteFunction#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; RemoteFunction.ClassName: symbol Refers to the ClassName Symbol of the RemoteFunction. "},{"title":"Functions​","type":1,"pageTitle":"RemoteFunction","url":"api/RemoteFunction#functions","content":" "},{"title":"OnClientInvoke​","type":1,"pageTitle":"RemoteFunction","url":"api/RemoteFunction#OnClientInvoke","content":"This item only works when running on the client. Client &lt;/&gt; RemoteFunction.OnClientInvoke(...: any) → () Called when the client is invoked by RemoteFunction:InvokeClient.  "},{"title":"OnServerInvoke​","type":1,"pageTitle":"RemoteFunction","url":"api/RemoteFunction#OnServerInvoke","content":"This item only works when running on the server. Server &lt;/&gt; RemoteFunction.OnServerInvoke( Player: Player , ...: any ) → () Called when the server is invoked by RemoteFunction:InvokeServer.  "},{"title":"inbound​","type":1,"pageTitle":"RemoteFunction","url":"api/RemoteFunction#inbound","content":"&lt;/&gt; RemoteFunction:inbound( hook: function,-- The function to be called when the RemoteFunction receives a request. context: &quot;Shared&quot; | &quot;Server&quot; | &quot;Client&quot;,-- The context in which the hook should be called. config: any-- An optional configuration value to be passed to the hook. ) → RemoteFunction-- Returns self. This function is used to hook into the RemoteFunction in two places: before an invocation callback is called and before an invocation response is returned. All inbound hooks are called in the order they are added. caution This function should only be used when you are registering your remotes!  "},{"title":"outbound​","type":1,"pageTitle":"RemoteFunction","url":"api/RemoteFunction#outbound","content":"&lt;/&gt; RemoteFunction:outbound( hook: function,-- The function to be called when the RemoteFunction receives a request. context: &quot;Shared&quot; | &quot;Server&quot; | &quot;Client&quot;,-- The context in which the hook should be called. config: any-- An optional configuration value to be passed to the hook. ) → RemoteFunction-- Returns self. This function is used to hook into the RemoteFunction in two places: after an invocation callback is called and before the remote is invoked. All outbound hooks are called in the order they are added. caution This function should only be used when you are registering your remotes!  "},{"title":"warn​","type":1,"pageTitle":"RemoteFunction","url":"api/RemoteFunction#warn","content":"&lt;/&gt; RemoteFunction:warn( value: boolean-- Defaults to false. ) → RemoteFunction-- Returns self. This function is used to set a flag that will automatically catch and warn errors thrown by hooks. caution This function should only be used when you are registering your remotes!  "},{"title":"InvokeClient​","type":1,"pageTitle":"RemoteFunction","url":"api/RemoteFunction#InvokeClient","content":"This item only works when running on the server. Server &lt;/&gt; RemoteFunction:InvokeClient( Client: Player ,-- The player to invoke. ...: any-- The arguments to pass to the invocation. ) → Promise-- Returns a promise that resolves when the remote has been invoked or fails if any hooks failed. Calls the method bound to RemoteFunction by RemoteFunction.OnClientInvoke for the given Player.  "},{"title":"InvokeServer​","type":1,"pageTitle":"RemoteFunction","url":"api/RemoteFunction#InvokeServer","content":"This item only works when running on the client. Client &lt;/&gt; RemoteFunction:InvokeServer( ...: any-- The arguments to pass to the invocation. ) → Promise-- Returns a promise that resolves when the remote has been invoked or fails if any hooks failed. Calls the method bound to RemoteFunction by RemoteFunction.OnServerInvoke. "},{"title":"Hooks","type":0,"sectionRef":"#","url":"docs/Hooks","content":"","keywords":""},{"title":"Input​","type":1,"pageTitle":"Hooks","url":"docs/Hooks#input","content":"Hooks have at least three parameters: Header, Config, and varargs. Header is a dictionary that looks like so: { Remote = Remote_Instance, -- Literal instance of your remote Type = &quot;Request&quot; | &quot;Response&quot; -- This field will only appear for RemoteFunction hooks } Copy Config is a single value (usually a dictionary) that is specified when you are defining your hook. This defaults to an empty table. varargs (...) refers to the arguments received from the remote. "},{"title":"Output​","type":1,"pageTitle":"Hooks","url":"docs/Hooks#output","content":"Hooks must return a Promise. Resolve the Promise with your mutated data. If you resolve nil, it will use the current reference. If you want to overwrite your data with nil, resolve Network.None. Reject the Promise if there is an error. This will abort the hook chain and the corresponding signal will never fire. You can catch this error with the promise returned by whatever method you used to Fire/Invoke the remote. "},{"title":"Register​","type":1,"pageTitle":"Hooks","url":"docs/Hooks#register","content":"See Register for more information on registering hooks. "},{"title":"Lifecycle​","type":1,"pageTitle":"Hooks","url":"docs/Hooks#lifecycle","content":"Understanding when and where hooks run is important. In general, inbound hooks run before data is received and outbound hooks run before data is sent. The specifics vary depending on the type of remote. "},{"title":"Remote Event Pipeline​","type":1,"pageTitle":"Hooks","url":"docs/Hooks#remote-event-pipeline","content":"FireClient/FireServer is called via Network API. This returns a promise.Outbound hooks are applied in order to corresponding arguments. If this fails, it halts here and the rejection is sent up the chain to step 1If this succeeds, it continues and the final version of the data is sent up the chain to step 1 FireClient/FireServer is actually called with new arguments via RemoteEvent instance.RemoteEvent received.Inbound hooks are applied in order to corresponding arguments. If this fails, the event handler is thrown.If this succeeds, the event handlers run. "},{"title":"Remote Function Pipeline​","type":1,"pageTitle":"Hooks","url":"docs/Hooks#remote-function-pipeline","content":"Internally, Remote Functions use two RemoteEvent instances instead of a RemoteFunction instance. This is because native RemoteFunctions can yield indefinitely. One RemoteEvent, Response, is used to listen for invocations. The other, Request, is used to invoke. InvokeServer/InvokeClient is called via Network API. This returns a promise.Outbound hooks are applied in order to corresponding arguments. If this fails, it halts here and the rejection is sent up the chain to step 1 Request RemoteEvent instance is called with the new arguments.RemoteEvent received.If there is no OnClientInvoke/OnServerInvoke callback, the Response RemoteEvent is fired with nil. Skip to step 9.Inbound hooks are applied in order to corresponding arguments. If this fails, it fails silently (unless Warn is true), and aborts the processIf this succeeds, OnClientInvoke/OnServerInvoke callback is called with (nil, ...new arguments) Outbound hooks are applied in order to response from callback. If this fails, it fails silently (unless Warn is true), and aborts the process Response RemoteEvent instance is called with the new response.Response received.Inbound hooks are applied in order to corresponding arguments. If this fails, promise from step 1 is rejected with corresponding error.If this succeeds, promise from step 1 is resolved with new response. "},{"title":"Type Header​","type":1,"pageTitle":"Hooks","url":"docs/Hooks#type-header","content":"You may have noticed that for RemoteFunctions inbound and outbound hooks are called both when data is sent and when data is received. This means that they have to contextually handle different kinds of data depending on the stage of the lifecycle they are being called in. This is what the Type field of the header is for. The Type is Request when: Outbound hooks are processing InvokeServer / InvokeClientInbound hooks are processing data received from an invocation The Type is Response when: Outbound hooks are processing data to be returned from an invocationInbound hooks are processing data that has just been returned from an invocation "},{"title":"Middleware​","type":1,"pageTitle":"Hooks","url":"docs/Hooks#middleware","content":"Middleware hooks are just hooks that don't mutate data. Some examples include: LoggerRate LimiterType CheckerPermission System It may be helpful to define these in a Middleware.lua file. ReplicatedStorage/Middleware.lua local Promise = require(...Promise) local function Logger(Header, Config, ...) print((&quot;[%s]&quot;):format(Header.Remote.Name), ...) return Promise.resolve() end return { Logger = Logger } Copy "},{"title":"Transformers​","type":1,"pageTitle":"Hooks","url":"docs/Hooks#transformers","content":"Transformers are hooks that do mutate data. Some examples include: Instance SerializerData Encoder It may be helpful to define these in a Transformers.lua file. ReplicatedStorage/Transformers.lua local Promise = require(...Promise) local base64 = require(...base64) local function Encode(Header, Config, ...) local data = {...} return Promise.new(function(resolve, reject) for key, value in pairs(data) do if type(value) == &quot;string&quot; then data[key] = base64.encode(value) end end resolve(unpack(data)) end) end return { Encode = Encode } Copy "},{"title":"Example​","type":1,"pageTitle":"Hooks","url":"docs/Hooks#example","content":"RemoteEvent that encodes data before it's sent and decodes it when it's received. ReplicatedStorage/Transformers.lua local base64 = require(...base64) local function Encode(Header, Config, ...) local data = {...} return Promise.new(function(resolve, reject) for key, value in pairs(data) do if type(value) == &quot;string&quot; then data[key] = base64.encode(value) end end resolve(unpack(data)) end) end local function Decode(Header, Config, ...) local data = {...} return Promise.new(function(resolve, reject) for key, value in pairs(data) do if type(value) == &quot;string&quot; then data[key] = base64.decode(value) end end resolve(unpack(data)) end) end return { Encode = Encode, Decode = Decode } Copy ReplicatedStorage/Remotes.lua local Middleware = require(...Middleware) local Transformers = require(...Transformers) return Network.Register({ Encoded = Network.Event.new() :inbound(Middleware.Logger, &quot;Shared&quot;) :inbound(Transformers.Decode, &quot;Shared&quot;) :outbound(Middleware.Logger, &quot;Shared&quot;) :outbound(Transformers.Encode, &quot;Shared&quot;) :warn(true) }) Copy StarterPlayerScripts/Main.lua local Remotes = require(...Remotes) Remotes.GetEvent(&quot;Encoded&quot;):FireServer(&quot;do re me fa&quot;, &quot;so la ti do&quot;):catch(warn) Copy ServerScriptService/Main.lua local Remotes = require(...Remotes) Remotes.GetEvent(&quot;Encoded&quot;).OnServerEvent:Connect(function(player, message) print(&quot;got&quot;, player, message) -- got player do re me fa so la ti do end):catch(warn) Copy "},{"title":"RemoteEvent","type":0,"sectionRef":"#","url":"api/RemoteEvent","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"RemoteEvent","url":"api/RemoteEvent#properties","content":" "},{"title":"Name​","type":1,"pageTitle":"RemoteEvent","url":"api/RemoteEvent#Name","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; RemoteEvent.Name: string Refers to the name given to the RemoteEvent.  "},{"title":"ClassName​","type":1,"pageTitle":"RemoteEvent","url":"api/RemoteEvent#ClassName","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; RemoteEvent.ClassName: symbol Refers to the ClassName Symbol of the RemoteEvent. "},{"title":"Functions​","type":1,"pageTitle":"RemoteEvent","url":"api/RemoteEvent#functions","content":" "},{"title":"OnClientEvent​","type":1,"pageTitle":"RemoteEvent","url":"api/RemoteEvent#OnClientEvent","content":"This item only works when running on the client. Client &lt;/&gt; RemoteEvent.OnClientEvent(...: any) → Connection(...) Fires listening functions when the server fires the RemoteEvent at this client.  "},{"title":"OnServerEvent​","type":1,"pageTitle":"RemoteEvent","url":"api/RemoteEvent#OnServerEvent","content":"This item only works when running on the server. Server &lt;/&gt; RemoteEvent.OnServerEvent( Player: Player , ...: any ) → Connection(Player,...) Fires listening functions when the client fires the RemoteEvent.  "},{"title":"inbound​","type":1,"pageTitle":"RemoteEvent","url":"api/RemoteEvent#inbound","content":"&lt;/&gt; RemoteEvent:inbound( hook: function,-- The function to be called when the RemoteEvent receives a request. context: &quot;Shared&quot; | &quot;Server&quot; | &quot;Client&quot;,-- The context in which the hook should be called. config: any-- An optional configuration value to be passed to the hook. ) → RemoteEvent-- Returns self. This function is used to hook into the RemoteEvent listener. All inbound hooks are called in the order they are added. tip This function can be chained. RemoteEvent :inbound(Middleware.Logger, &quot;Client&quot;) :inbound(Transformers.Decode, &quot;Client&quot;) caution This function should only be used when you are registering your remotes!  "},{"title":"outbound​","type":1,"pageTitle":"RemoteEvent","url":"api/RemoteEvent#outbound","content":"&lt;/&gt; RemoteEvent:outbound( hook: function,-- The function to be called when the RemoteEvent receives a request. context: &quot;Shared&quot; | &quot;Server&quot; | &quot;Client&quot;,-- The context in which the hook should be called. config: any-- An optional configuration value to be passed to the hook. ) → RemoteEvent-- Returns self. This function is used to hook into the RemoteEvent before it fires. All outbound hooks are called in the order they are added. tip This function can be chained. RemoteEvent :outbound(Middleware.Logger, &quot;Server&quot;) :outbound(Transformers.Encode, &quot;Server&quot;) caution This function should only be used when you are registering your remotes!  "},{"title":"warn​","type":1,"pageTitle":"RemoteEvent","url":"api/RemoteEvent#warn","content":"&lt;/&gt; RemoteEvent:warn( value: boolean-- Defaults to false. ) → RemoteEvent-- Returns self. This function is used to set a flag that will automatically catch and warn errors thrown by hooks. tip This function can be chained. RemoteEvent :inbound(Middleware.Logger, &quot;Shared&quot;) :inbound(Transformers.Decode, &quot;Client&quot;) :outbound(Middleware.Logger, &quot;Server&quot;) :outbound(Transformers.Encode, &quot;Server&quot;) :warn(true) caution This function should only be used when you are registering your remotes!  "},{"title":"FireClient​","type":1,"pageTitle":"RemoteEvent","url":"api/RemoteEvent#FireClient","content":"This item only works when running on the server. Server &lt;/&gt; RemoteEvent:FireClient( Player: Player ,-- The player to fire the event for. ...: any-- The arguments to pass to the event. ) → Promise-- Returns a promise that resolves when the event has been fired or fails if any hooks failed. Fires RemoteEvent.OnClientEvent for the specified player.  "},{"title":"FireAllClients​","type":1,"pageTitle":"RemoteEvent","url":"api/RemoteEvent#FireAllClients","content":"This item only works when running on the server. Server &lt;/&gt; RemoteEvent:FireAllClients( ...: any-- The arguments to pass to the event. ) → Promise-- Returns a promise that resolves when the event has been fired or fails if any hooks failed. Fires RemoteEvent.OnClientEvent for all players.  "},{"title":"FireClients​","type":1,"pageTitle":"RemoteEvent","url":"api/RemoteEvent#FireClients","content":"This item only works when running on the server. Server &lt;/&gt; RemoteEvent:FireClients( List: {[number]: Player },-- The players to fire the event for. ...: any-- The arguments to pass to the event. ) → Promise-- Returns a promise that resolves when the event has been fired or fails if any hooks failed. Fires RemoteEvent.OnClientEvent for specified players.  "},{"title":"FireClientsExcept​","type":1,"pageTitle":"RemoteEvent","url":"api/RemoteEvent#FireClientsExcept","content":"This item only works when running on the server. Server &lt;/&gt; RemoteEvent:FireClientsExcept( List: {[number]: Player },-- The players not to fire the event for. ...: any-- The arguments to pass to the event. ) → Promise-- Returns a promise that resolves when the event has been fired or fails if any hooks failed. Fires RemoteEvent.OnClientEvent for all players except those in the list.  "},{"title":"FireServer​","type":1,"pageTitle":"RemoteEvent","url":"api/RemoteEvent#FireServer","content":"This item only works when running on the client. Client &lt;/&gt; RemoteEvent:FireServer( ...: any-- The arguments to pass to the event. ) → Promise-- Returns a promise that resolves when the event has been fired or fails if any hooks failed. Fires RemoteEvent.OnServerEvent on the server using the arguments specified with an additional player argument at the beginning. "}]