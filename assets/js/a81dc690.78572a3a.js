"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[32],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),d=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=d(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=d(n),m=a,k=c["".concat(s,".").concat(m)]||c[m]||p[m]||o;return n?r.createElement(k,i(i({ref:t},u),{},{components:n})):r.createElement(k,i({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var d=2;d<o;d++)i[d]=n[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},43335:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return u},default:function(){return c}});var r=n(87462),a=n(63366),o=(n(67294),n(3905)),i=["components"],l={sidebar_position:5},s="Hooks",d={unversionedId:"Hooks",id:"Hooks",isDocsHomePage:!1,title:"Hooks",description:"It can be convenient to track or modify data being sent or received from remotes. Hooks allow you to do this by hooking in to remote logic at different stages in its life cycle. This is useful for things like logging, rate limiting, permission systems, type checking, serializing data, and more.",source:"@site/docs/Hooks.md",sourceDirName:".",slug:"/Hooks",permalink:"/Network/docs/Hooks",editUrl:"https://github.com/call23re/Network/edit/master/docs/Hooks.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"defaultSidebar",previous:{title:"Remote Functions",permalink:"/Network/docs/Getting Started/Remote Functions"},next:{title:"Chaining",permalink:"/Network/docs/Chaining"}},u=[{value:"Input",id:"input",children:[],level:2},{value:"Output",id:"output",children:[],level:2},{value:"Register",id:"register",children:[],level:2},{value:"Lifecycle",id:"lifecycle",children:[{value:"Remote Event Pipeline",id:"remote-event-pipeline",children:[],level:3},{value:"Remote Function Pipeline",id:"remote-function-pipeline",children:[],level:3},{value:"Type Header",id:"type-header",children:[],level:3}],level:2},{value:"Middleware",id:"middleware",children:[],level:2},{value:"Transformers",id:"transformers",children:[],level:2},{value:"Example",id:"example",children:[],level:2}],p={toc:u};function c(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"hooks"},"Hooks"),(0,o.kt)("p",null,"It can be convenient to track or modify data being sent or received from remotes. Hooks allow you to do this by hooking in to remote logic at different stages in its life cycle. This is useful for things like logging, rate limiting, permission systems, type checking, serializing data, and more."),(0,o.kt)("p",null,"Hooks are functions with specific parameters that return a promise. They are very similar to middleware except they can mutate data and they work in both the inbound and outbound directions. It can be helpful to think of non-mutating hooks as ",(0,o.kt)("a",{parentName:"p",href:"#middleware"},"Middleware")," and mutating hooks as ",(0,o.kt)("a",{parentName:"p",href:"#transformers"},"Transformers"),". Hooks are called in the order that they are defined. Inbound hooks are called just before any remote listeners are activated. Outbound hooks are called just before a remote is actually fired/invoked."),(0,o.kt)("h2",{id:"input"},"Input"),(0,o.kt)("p",null,"Hooks have at least three parameters: ",(0,o.kt)("inlineCode",{parentName:"p"},"Header"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Config"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"varargs"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Header")," is a dictionary that looks like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua"},'{\n    Remote = Remote_Instance, -- Literal instance of your remote\n    Type = "Request" | "Response" -- This field will only appear for RemoteFunction hooks\n}\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Config")," is a single value (usually a dictionary) that is specified when you are defining your hook. This defaults to an empty table."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"varargs")," (",(0,o.kt)("inlineCode",{parentName:"p"},"..."),") refers to the arguments received from the remote."),(0,o.kt)("h2",{id:"output"},"Output"),(0,o.kt)("p",null,"Hooks ",(0,o.kt)("strong",{parentName:"p"},"must")," return a ",(0,o.kt)("a",{parentName:"p",href:"https://eryn.io/roblox-lua-promise/"},"Promise"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Resolve")," the Promise with your mutated data. If you resolve ",(0,o.kt)("em",{parentName:"p"},"nil"),", it will use the current reference. If you want to overwrite your data with nil, resolve ",(0,o.kt)("inlineCode",{parentName:"p"},"Network.None"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Reject")," the Promise if there is an error. This will abort the hook chain and the corresponding signal will never fire. You can catch this error with the promise returned by whatever method you used to Fire/Invoke the remote."),(0,o.kt)("h2",{id:"register"},"Register"),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"./Getting%20Started/Register"},"Register")," for more information on registering hooks."),(0,o.kt)("h2",{id:"lifecycle"},"Lifecycle"),(0,o.kt)("p",null,"Understanding ",(0,o.kt)("em",{parentName:"p"},"when")," and ",(0,o.kt)("em",{parentName:"p"},"where")," hooks run is important. In general, inbound hooks run before data is received and outbound hooks run before data is sent. The specifics vary depending on the type of remote."),(0,o.kt)("h3",{id:"remote-event-pipeline"},"Remote Event Pipeline"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"FireClient/FireServer is called via Network API. This returns a promise."),(0,o.kt)("li",{parentName:"ol"},"Outbound hooks are applied in order to corresponding arguments.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"If this fails, it halts here and the rejection is sent up the chain to step 1"),(0,o.kt)("li",{parentName:"ul"},"If this succeeds, it continues and the final version of the data is sent up the chain to step 1"))),(0,o.kt)("li",{parentName:"ol"},"FireClient/FireServer is actually called with new arguments via RemoteEvent instance."),(0,o.kt)("li",{parentName:"ol"},"RemoteEvent received."),(0,o.kt)("li",{parentName:"ol"},"Inbound hooks are applied in order to corresponding arguments.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"If this fails, the event handler is thrown."),(0,o.kt)("li",{parentName:"ul"},"If this succeeds, the event handlers run.")))),(0,o.kt)("h3",{id:"remote-function-pipeline"},"Remote Function Pipeline"),(0,o.kt)("p",null,"Internally, Remote Functions use two RemoteEvent instances instead of a RemoteFunction instance. This is because native RemoteFunctions can yield indefinitely. One RemoteEvent, ",(0,o.kt)("em",{parentName:"p"},"Response"),", is used to listen for invocations. The other, ",(0,o.kt)("em",{parentName:"p"},"Request"),", is used to invoke."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"InvokeServer/InvokeClient is called via Network API. This returns a promise."),(0,o.kt)("li",{parentName:"ol"},"Outbound hooks are applied in order to corresponding arguments.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"If this fails, it halts here and the rejection is sent up the chain to step 1"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("em",{parentName:"li"},"Request")," RemoteEvent instance is called with the new arguments."),(0,o.kt)("li",{parentName:"ol"},"RemoteEvent received."),(0,o.kt)("li",{parentName:"ol"},"If there is no OnClientInvoke/OnServerInvoke callback, the ",(0,o.kt)("em",{parentName:"li"},"Response")," RemoteEvent is fired with nil. Skip to step 9."),(0,o.kt)("li",{parentName:"ol"},"Inbound hooks are applied in order to corresponding arguments.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"If this fails, it fails silently (unless Warn is true), and aborts the process"),(0,o.kt)("li",{parentName:"ul"},"If this succeeds, OnClientInvoke/OnServerInvoke callback is called with (nil, ...new arguments)"))),(0,o.kt)("li",{parentName:"ol"},"Outbound hooks are applied in order to response from callback.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"If this fails, it fails silently (unless Warn is true), and aborts the process"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("em",{parentName:"li"},"Response")," RemoteEvent instance is called with the new response."),(0,o.kt)("li",{parentName:"ol"},"Response received."),(0,o.kt)("li",{parentName:"ol"},"Inbound hooks are applied in order to corresponding arguments.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"If this fails, promise from step 1 is rejected with corresponding error."),(0,o.kt)("li",{parentName:"ul"},"If this succeeds, promise from step 1 is resolved with new response.")))),(0,o.kt)("h3",{id:"type-header"},"Type Header"),(0,o.kt)("p",null,"You may have noticed that for RemoteFunctions inbound and outbound hooks are called both when data is sent and when data is received. This means that they have to contextually handle different kinds of data depending on the stage of the lifecycle they are being called in. This is what the ",(0,o.kt)("inlineCode",{parentName:"p"},"Type")," field of the header is for."),(0,o.kt)("p",null,"The Type is ",(0,o.kt)("inlineCode",{parentName:"p"},"Request")," when:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Outbound hooks are processing InvokeServer / InvokeClient"),(0,o.kt)("li",{parentName:"ul"},"Inbound hooks are processing data received from an invocation")),(0,o.kt)("p",null,"The Type is ",(0,o.kt)("inlineCode",{parentName:"p"},"Response")," when:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Outbound hooks are processing data to be returned from an invocation"),(0,o.kt)("li",{parentName:"ul"},"Inbound hooks are processing data that has just been returned from an invocation")),(0,o.kt)("h2",{id:"middleware"},"Middleware"),(0,o.kt)("p",null,"Middleware hooks are just hooks that don't mutate data. Some examples include:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Logger"),(0,o.kt)("li",{parentName:"ul"},"Rate Limiter"),(0,o.kt)("li",{parentName:"ul"},"Type Checker"),(0,o.kt)("li",{parentName:"ul"},"Permission System")),(0,o.kt)("p",null,"It may be helpful to define these in a ",(0,o.kt)("inlineCode",{parentName:"p"},"Middleware.lua")," file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="ReplicatedStorage/Middleware.lua"',title:'"ReplicatedStorage/Middleware.lua"'},'local Promise = require(...Promise)\n\nlocal function Logger(Header, Config, ...)\n    print(("[%s]"):format(Header.Remote.Name), ...)\n    return Promise.resolve()\nend\n\nreturn {\n    Logger = Logger\n}\n')),(0,o.kt)("h2",{id:"transformers"},"Transformers"),(0,o.kt)("p",null,"Transformers are hooks that do mutate data. Some examples include:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Instance Serializer"),(0,o.kt)("li",{parentName:"ul"},"Data Encoder")),(0,o.kt)("p",null,"It may be helpful to define these in a ",(0,o.kt)("inlineCode",{parentName:"p"},"Transformers.lua")," file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="ReplicatedStorage/Transformers.lua"',title:'"ReplicatedStorage/Transformers.lua"'},'local Promise = require(...Promise)\nlocal base64 = require(...base64)\n\nlocal function Encode(Header, Config, ...)\n    local data = {...}\n    return Promise.new(function(resolve, reject)\n        for key, value in pairs(data) do\n            if type(value) == "string" then\n                data[key] = base64.encode(value)\n            end\n        end\n        resolve(unpack(data))\n    end)\nend\n\nreturn {\n    Encode = Encode\n}\n')),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("p",null,"RemoteEvent that encodes data before it's sent and decodes it when it's received."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="ReplicatedStorage/Transformers.lua"',title:'"ReplicatedStorage/Transformers.lua"'},'local base64 = require(...base64)\n\nlocal function Encode(Header, Config, ...)\n    local data = {...}\n    return Promise.new(function(resolve, reject)\n        for key, value in pairs(data) do\n            if type(value) == "string" then\n                data[key] = base64.encode(value)\n            end\n        end\n        resolve(unpack(data))\n    end)\nend\n\nlocal function Decode(Header, Config, ...)\n    local data = {...}\n    return Promise.new(function(resolve, reject)\n        for key, value in pairs(data) do\n            if type(value) == "string" then\n                data[key] = base64.decode(value)\n            end\n        end\n        resolve(unpack(data))\n    end)\nend\n\nreturn {\n    Encode = Encode,\n    Decode = Decode\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="ReplicatedStorage/Remotes.lua"',title:'"ReplicatedStorage/Remotes.lua"'},'local Middleware = require(...Middleware)\nlocal Transformers = require(...Transformers)\n\nreturn Network.Register({\n    Encoded = Network.Event.new()\n        :inbound(Middleware.Logger, "Shared")\n        :inbound(Transformers.Decode, "Shared")\n        :outbound(Middleware.Logger, "Shared")\n        :outbound(Transformers.Encode, "Shared")\n        :warn(true)\n})\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="StarterPlayerScripts/Main.lua"',title:'"StarterPlayerScripts/Main.lua"'},'local Remotes = require(...Remotes)\nRemotes.GetEvent("Encoded"):FireServer("do re me fa", "so la ti do"):catch(warn)\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lua",metastring:'title="ServerScriptService/Main.lua"',title:'"ServerScriptService/Main.lua"'},'local Remotes = require(...Remotes)\nRemotes.GetEvent("Encoded").OnServerEvent:Connect(function(player, message)\n    print("got", player, message)\n    -- got player do re me fa so la ti do\nend):catch(warn)\n')))}c.isMDXComponent=!0}}]);